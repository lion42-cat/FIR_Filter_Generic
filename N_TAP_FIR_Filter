`timescale 1ns / 1ps
`define FIR_tap 16
// Resource_optimized FIR Filter임 (16_tap FIR Filter) //
//////////////////////////////////////////////////////////////////////////////////
module N_TAP_FIR_Filter(clk, rst, data_in, data_out);

input clk, rst;
input [15:0] data_in;
output [15:0] data_out;

reg [15:0] xn [`FIR_tap-1:0];
reg [15:0] prod [(`FIR_tap/2):0];
reg [15:0] mac [(`FIR_tap/2):0];
wire [15:0] yn;
reg [15:0] data_out;

reg [15:0] b[(`FIR_tap/2):0];

integer i;

reg [15:0] temporary_FIR_TAP;
//MSB for prod,mac //짝수홀수 판별
always @ (posedge clk)
begin
	if(rst == 1)
		begin
			temporary_FIR_TAP <= 0;
		end
	else
		begin
			if((`FIR_tap & 1) == 1) //Tap이 홀수
				temporary_FIR_TAP <= (`FIR_tap /2);
			else					//Tap이 짝수
				temporary_FIR_TAP <= ((`FIR_tap /2) - 1);
		end
end

//coefficient
always @ (posedge clk)
begin
	if(rst == 1)
		begin
		for(i=0; i<=(`FIR_tap/2); i=i+1)
			b[i] = 0;
		end
	else
		begin
			b[0] = 16'd0001;
			b[1] = 16'd0002;
			b[2] = 16'd0003;
			b[3] = 16'd0004;
			b[4] = 16'd0005;
			b[5] = 16'd0006;
			b[6] = 16'd0007;
			b[7] = 16'd0008;
			b[8] = 16'd0009;
		end
end


integer i;
//xn
always @ (posedge clk)
begin
	if(rst == 1)
		begin
			for(i=0; i<=(`FIR_tap-1); i=i+1)
					xn[i] = 0;
		end
	else
		begin			
			for(i=0; i<=(`FIR_tap-1); i=i+1)
				if(i==0)
						begin
							xn[0] <= data_in;
						end
					else
						begin
							xn[i] <= xn[i-1];
						end
		end
end

integer j;
//prod
always @ (posedge clk)
begin
	if(rst == 1)
		begin
			for(i=0; i<=temporary_FIR_TAP; i=i+1)
				prod[i] = 0;
		end
	else
		begin
			if((`FIR_tap & 1) == 1) //FIR_tap이 홀수
				begin
					for(j=0; j<=temporary_FIR_TAP-1; j=j+1)
						begin
							prod[j] <= b[j] * (xn[j] + xn[`FIR_tap - 1 -j]);
						end
					prod[(temporary_FIR_TAP/2)+1] <= b[temporary_FIR_TAP/2+1] * xn[temporary_FIR_TAP/2];
				end
			else					//FIR_tap이 짝수
				begin
					for(j=0; j<=temporary_FIR_TAP; j=j+1)
						prod[j] <= b[j] * (xn[j] + xn[`FIR_tap - 1 - j]);
				end
		end
end

integer k;
//mac
always @ (posedge clk)
begin
	if(rst == 1)
		begin
			for(k=0; k<=temporary_FIR_TAP; k=k+1)
				mac[k] = 0;
		end
	else
		begin
		mac[0] = prod[0];
			for(k=1; k<=temporary_FIR_TAP; k=k+1)
				mac[k] = mac[k-1] + prod[k]; 
		end
end

assign yn = mac[7];


//data_out
always @ (posedge clk)
begin
	if(rst == 1)
		begin
			data_out[15:0] = 0;
		end
	else
		begin
			data_out <= yn[15:0];
		end
end

endmodule
